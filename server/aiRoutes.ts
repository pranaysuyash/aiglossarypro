import type { Express } from "express";
import { aiService } from "./aiService";
import { storage } from "./storage";
import { isAuthenticated } from "./replitAuth";
import { isUserAdmin } from "./utils/authUtils";

export function registerAIRoutes(app: Express): void {
  // Generate definition for a new term
  app.post('/api/ai/generate-definition', isAuthenticated, async (req: any, res) => {
    try {
      const { term, category, context } = req.body;
      const userId = req.user.claims.sub;
      
      if (!term || typeof term !== 'string') {
        return res.status(400).json({ 
          success: false, 
          error: 'Term is required and must be a string' 
        });
      }

      const result = await aiService.generateDefinition(term, category, context, userId);
      
      res.json({
        success: true,
        data: result,
        metadata: {
          aiGenerated: true,
          model: 'gpt-4.1-nano',
          verificationStatus: 'unverified',
          disclaimer: 'This content was generated by AI and requires expert review for accuracy.'
        }
      });
    } catch (error) {
      console.error('Error generating definition:', error);
      res.status(500).json({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to generate definition'
      });
    }
  });

  // Get term suggestions
  app.get('/api/ai/term-suggestions', isAuthenticated, async (req: any, res) => {
    try {
      const focusCategory = req.query.category as string;
      const limit = parseInt(req.query.limit as string) || 8;
      
      // Get existing terms and categories
      const categories = await storage.getCategories();
      const existingTerms = await storage.getAllTermNames();
      
      const result = await aiService.generateTermSuggestions(
        existingTerms, 
        categories, 
        focusCategory
      );
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error generating term suggestions:', error);
      res.status(500).json({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to generate suggestions'
      });
    }
  });

  // Categorize a term
  app.post('/api/ai/categorize-term', isAuthenticated, async (req: any, res) => {
    try {
      const { term, definition } = req.body;
      
      if (!term || !definition) {
        return res.status(400).json({ 
          success: false, 
          error: 'Term and definition are required' 
        });
      }

      const categories = await storage.getCategories();
              const result = await aiService.categorizeTerm(term, definition, categories);
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error categorizing term:', error);
      res.status(500).json({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to categorize term'
      });
    }
  });

  // Enhanced semantic search with cost optimization
  app.post('/api/ai/semantic-search', async (req: any, res) => {
    try {
      const { query, limit = 10 } = req.body;
      const userId = req.isAuthenticated?.() ? req.user.claims.sub : null;
      
      if (!query || typeof query !== 'string') {
        return res.status(400).json({ 
          success: false, 
          error: 'Search query is required' 
        });
      }

      if (query.length < 3) {
        return res.json({
          success: true,
          data: { matches: [] },
          message: 'Query too short for semantic search'
        });
      }

      // Get optimized term set for search (limit to reduce costs)
      const searchLimit = Math.min(100, limit * 10);
      const allTerms = await storage.getAllTermsForSearch(searchLimit);
      const result = await aiService.semanticSearch(query, allTerms, limit, userId);
      
      res.json({
        success: true,
        data: result,
        metadata: {
          searchedTerms: allTerms.length,
          model: 'gpt-3.5-turbo', // Cost-optimized model
          costOptimized: true
        }
      });
    } catch (error) {
      console.error('Error performing semantic search:', error);
      res.status(500).json({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to perform semantic search'
      });
    }
  });

  // Improve existing term definition
  app.post('/api/ai/improve-definition/:id', isAuthenticated, async (req: any, res) => {
    try {
      const termId = req.params.id;
      
      const term = await storage.getTermById(termId);
      if (!term) {
        return res.status(404).json({ 
          success: false, 
          error: 'Term not found' 
        });
      }

      const result = await aiService.improveDefinition(term);
      
      res.json({
        success: true,
        data: result,
        originalTerm: term,
        metadata: {
          aiGenerated: true,
          model: 'gpt-4.1-nano',
          verificationStatus: 'unverified',
          disclaimer: 'These improvements were generated by AI and require review before application.'
        }
      });
    } catch (error) {
      console.error('Error improving definition:', error);
      res.status(500).json({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to improve definition'
      });
    }
  });

  // Apply AI-generated improvements to a term
  app.put('/api/ai/apply-improvements/:id', isAuthenticated, async (req: any, res) => {
    try {
      const termId = req.params.id;
      const { improvements } = req.body;
      
      // Only allow admin to apply improvements
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({ 
          success: false, 
          error: "Admin privileges required" 
        });
      }

      const term = await storage.getTermById(termId);
      if (!term) {
        return res.status(404).json({ 
          success: false, 
          error: 'Term not found' 
        });
      }

      // Update the term with AI improvements
      const updatedTerm = await storage.updateTerm(termId, {
        shortDefinition: improvements.shortDefinition || term.shortDefinition,
        definition: improvements.definition || term.definition,
        characteristics: improvements.characteristics || term.characteristics,
        applications: improvements.applications || term.applications,
        mathFormulation: improvements.mathFormulation || term.mathFormulation
      });

      res.json({
        success: true,
        data: updatedTerm
      });
    } catch (error) {
      console.error('Error applying improvements:', error);
      res.status(500).json({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to apply improvements'
      });
    }
  });

  // ========================
  // AI Content Feedback System
  // ========================

  // Submit feedback on AI-generated content
  app.post('/api/ai/feedback', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { 
        termId, 
        feedbackType, 
        section, 
        description, 
        severity = 'medium' 
      } = req.body;

      if (!termId || !feedbackType || !description) {
        return res.status(400).json({
          success: false,
          error: 'Term ID, feedback type, and description are required'
        });
      }

      const validFeedbackTypes = ['incorrect', 'incomplete', 'misleading', 'outdated', 'other'];
      if (!validFeedbackTypes.includes(feedbackType)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid feedback type'
        });
      }

      // TODO: Implement database insertion for ai_content_feedback table
      // This would be implemented with the enhanced storage layer
      
      res.json({
        success: true,
        message: 'Feedback submitted successfully',
        data: {
          feedbackId: 'temp-id', // Would be actual ID from database
          status: 'pending'
        }
      });
    } catch (error) {
      console.error('Error submitting feedback:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to submit feedback'
      });
    }
  });

  // Get feedback for a term (admin only)
  app.get('/api/ai/feedback/:termId', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Admin privileges required'
        });
      }

      const termId = req.params.termId;
      
      // TODO: Implement database query for feedback
      res.json({
        success: true,
        data: {
          feedback: [], // Would be actual feedback from database
          summary: {
            total: 0,
            pending: 0,
            resolved: 0
          }
        }
      });
    } catch (error) {
      console.error('Error fetching feedback:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch feedback'
      });
    }
  });

  // Update feedback status (admin only)
  app.put('/api/ai/feedback/:feedbackId', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Admin privileges required'
        });
      }

      const feedbackId = req.params.feedbackId;
      const { status, reviewNotes } = req.body;

      const validStatuses = ['pending', 'reviewing', 'resolved', 'dismissed'];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid status'
        });
      }

      // TODO: Implement database update for feedback status
      
      res.json({
        success: true,
        message: 'Feedback status updated successfully'
      });
    } catch (error) {
      console.error('Error updating feedback:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update feedback'
      });
    }
  });

  // ========================
  // AI Content Verification
  // ========================

  // Get verification status for a term
  app.get('/api/ai/verification/:termId', async (req: any, res) => {
    try {
      const termId = req.params.termId;
      
      // TODO: Implement database query for verification status
      res.json({
        success: true,
        data: {
          isAiGenerated: false,
          verificationStatus: 'unverified',
          confidenceLevel: 'medium',
          lastReviewed: null,
          expertReviewRequired: false
        }
      });
    } catch (error) {
      console.error('Error fetching verification status:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch verification status'
      });
    }
  });

  // Update verification status (admin only)
  app.put('/api/ai/verification/:termId', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Admin privileges required'
        });
      }

      const termId = req.params.termId;
      const { verificationStatus, expertReviewNotes } = req.body;

      const validStatuses = ['unverified', 'verified', 'flagged', 'needs_review', 'expert_reviewed'];
      if (!validStatuses.includes(verificationStatus)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid verification status'
        });
      }

      // TODO: Implement database update for verification status
      
      res.json({
        success: true,
        message: 'Verification status updated successfully'
      });
    } catch (error) {
      console.error('Error updating verification status:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update verification status'
      });
    }
  });

  // ========================
  // AI Analytics and Monitoring
  // ========================

  // Get AI usage analytics (admin only)
  app.get('/api/ai/analytics', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Admin privileges required'
        });
      }

      const { timeframe = '7d', operation } = req.query;
      
      // Parse timeframe
      const days = timeframe === '24h' ? 1 : timeframe === '7d' ? 7 : timeframe === '30d' ? 30 : 7;
      const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
      
      const { db } = await import('./db');
      const { aiUsageAnalytics } = await import('../shared/enhancedSchema');
      const { sql, gte, eq, and, desc } = await import('drizzle-orm');
      
      // Base query conditions
      const conditions = [gte(aiUsageAnalytics.createdAt, startDate)];
      if (operation) {
        conditions.push(eq(aiUsageAnalytics.operation, operation as string));
      }
      
      // Get summary statistics
      const [summaryResult] = await db.select({
        totalRequests: sql<number>`count(*)`,
        totalCost: sql<number>`sum(${aiUsageAnalytics.cost}::numeric)`,
        averageLatency: sql<number>`avg(${aiUsageAnalytics.latency})`,
        successRate: sql<number>`(count(*) filter (where ${aiUsageAnalytics.success} = true) * 100.0 / count(*))`,
        totalInputTokens: sql<number>`sum(${aiUsageAnalytics.inputTokens})`,
        totalOutputTokens: sql<number>`sum(${aiUsageAnalytics.outputTokens})`
      })
      .from(aiUsageAnalytics)
      .where(and(...conditions));
      
      // Get breakdown by operation
      const byOperation = await db.select({
        operation: aiUsageAnalytics.operation,
        count: sql<number>`count(*)`,
        totalCost: sql<number>`sum(${aiUsageAnalytics.cost}::numeric)`,
        avgLatency: sql<number>`avg(${aiUsageAnalytics.latency})`
      })
      .from(aiUsageAnalytics)
      .where(and(...conditions))
      .groupBy(aiUsageAnalytics.operation)
      .orderBy(desc(sql`count(*)`));
      
      // Get breakdown by model
      const byModel = await db.select({
        model: aiUsageAnalytics.model,
        count: sql<number>`count(*)`,
        totalCost: sql<number>`sum(${aiUsageAnalytics.cost}::numeric)`,
        avgLatency: sql<number>`avg(${aiUsageAnalytics.latency})`
      })
      .from(aiUsageAnalytics)
      .where(and(...conditions))
      .groupBy(aiUsageAnalytics.model)
      .orderBy(desc(sql`count(*)`));
      
      // Get timeline data (daily breakdown)
      const timeline = await db.select({
        date: sql<string>`date(${aiUsageAnalytics.createdAt})`,
        requests: sql<number>`count(*)`,
        cost: sql<number>`sum(${aiUsageAnalytics.cost}::numeric)`,
        errors: sql<number>`count(*) filter (where ${aiUsageAnalytics.success} = false)`
      })
      .from(aiUsageAnalytics)
      .where(and(...conditions))
      .groupBy(sql`date(${aiUsageAnalytics.createdAt})`)
      .orderBy(sql`date(${aiUsageAnalytics.createdAt})`);

      res.json({
        success: true,
        data: {
          summary: {
            totalRequests: Number(summaryResult?.totalRequests || 0),
            totalCost: Number(summaryResult?.totalCost || 0),
            averageLatency: Math.round(Number(summaryResult?.averageLatency || 0)),
            successRate: Math.round(Number(summaryResult?.successRate || 0) * 100) / 100,
            totalInputTokens: Number(summaryResult?.totalInputTokens || 0),
            totalOutputTokens: Number(summaryResult?.totalOutputTokens || 0)
          },
          byOperation: byOperation.reduce((acc, item) => {
            acc[item.operation] = {
              count: Number(item.count),
              totalCost: Number(item.totalCost || 0),
              avgLatency: Math.round(Number(item.avgLatency || 0))
            };
            return acc;
          }, {} as Record<string, any>),
          byModel: byModel.reduce((acc, item) => {
            acc[item.model] = {
              count: Number(item.count),
              totalCost: Number(item.totalCost || 0),
              avgLatency: Math.round(Number(item.avgLatency || 0))
            };
            return acc;
          }, {} as Record<string, any>),
          timeline: timeline.map(item => ({
            date: item.date,
            requests: Number(item.requests),
            cost: Number(item.cost || 0),
            errors: Number(item.errors)
          }))
        }
      });
    } catch (error) {
      console.error('Error fetching AI analytics:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch AI analytics'
      });
    }
  });

  // Get AI service health and status
  app.get('/api/ai/status', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Admin privileges required'
        });
      }

      const cacheStats = aiService.getCacheStats();
      const rateLimitStatus = aiService.getRateLimitStatus();

      res.json({
        success: true,
        data: {
          status: 'healthy',
          models: {
            primary: 'gpt-4.1-nano',
            secondary: 'gpt-3.5-turbo'
          },
          cache: cacheStats,
          rateLimit: rateLimitStatus,
          lastUpdated: new Date().toISOString()
        }
      });
    } catch (error) {
      console.error('Error fetching AI status:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch AI status'
      });
    }
  });
}