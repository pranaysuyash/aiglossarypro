import type { Express } from "express";
import { aiService } from "./aiService";
import { optimizedStorage as storage } from "./optimizedStorage";
import { mockIsAuthenticated } from "./middleware/dev/mockAuth";
import { isUserAdmin } from "./utils/authUtils";

export function registerAIRoutes(app: Express): void {
  // Generate definition for a new term
  app.post('/api/ai/generate-definition', mockIsAuthenticated, async (req: any, res) => {
    try {
      const { term, category, context } = req.body;
      const userId = req.user.claims.sub;
      
      if (!term || typeof term !== 'string') {
        return res.status(400).json({ 
          success: false, 
          error: 'Term is required and must be a string' 
        });
      }

      const result = await aiService.generateDefinition(term, category, context, userId);
      
      res.json({
        success: true,
        data: result,
        metadata: {
          aiGenerated: true,
          model: 'gpt-4.1-nano',
          verificationStatus: 'unverified',
          disclaimer: 'This content was generated by AI and requires expert review for accuracy.'
        }
      });
    } catch (error) {
      console.error('Error generating definition:', error);
      res.status(500).json({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to generate definition'
      });
    }
  });

  // Get term suggestions
  app.get('/api/ai/term-suggestions', mockIsAuthenticated, async (req: any, res) => {
    try {
      const focusCategory = req.query.category as string;
      const limit = parseInt(req.query.limit as string) || 8;
      
      // Get existing terms and categories
      const categories = await storage.getCategories();
      const existingTerms = await storage.getAllTermNames();
      
      const result = await aiService.generateTermSuggestions(
        existingTerms, 
        categories, 
        focusCategory
      );
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error generating term suggestions:', error);
      res.status(500).json({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to generate suggestions'
      });
    }
  });

  // Categorize a term
  app.post('/api/ai/categorize-term', mockIsAuthenticated, async (req: any, res) => {
    try {
      const { term, definition } = req.body;
      
      if (!term || !definition) {
        return res.status(400).json({ 
          success: false, 
          error: 'Term and definition are required' 
        });
      }

      const categories = await storage.getCategories();
              const result = await aiService.categorizeTerm(term, definition, categories);
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error categorizing term:', error);
      res.status(500).json({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to categorize term'
      });
    }
  });

  // Enhanced semantic search with cost optimization
  app.post('/api/ai/semantic-search', async (req: any, res) => {
    try {
      const { query, limit = 10 } = req.body;
      const userId = req.mockIsAuthenticated?.() ? req.user.claims.sub : null;
      
      if (!query || typeof query !== 'string') {
        return res.status(400).json({ 
          success: false, 
          error: 'Search query is required' 
        });
      }

      if (query.length < 3) {
        return res.json({
          success: true,
          data: { matches: [] },
          message: 'Query too short for semantic search'
        });
      }

      // Get optimized term set for search (limit to reduce costs)
      const searchLimit = Math.min(100, limit * 10);
      const allTerms = await storage.getAllTermsForSearch(searchLimit);
      const result = await aiService.semanticSearch(query, allTerms, limit, userId);
      
      res.json({
        success: true,
        data: result,
        metadata: {
          searchedTerms: allTerms.length,
          model: 'gpt-3.5-turbo', // Cost-optimized model
          costOptimized: true
        }
      });
    } catch (error) {
      console.error('Error performing semantic search:', error);
      res.status(500).json({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to perform semantic search'
      });
    }
  });

  // Improve existing term definition
  app.post('/api/ai/improve-definition/:id', mockIsAuthenticated, async (req: any, res) => {
    try {
      const termId = req.params.id;
      
      const term = await storage.getTermById(termId);
      if (!term) {
        return res.status(404).json({ 
          success: false, 
          error: 'Term not found' 
        });
      }

      const result = await aiService.improveDefinition(term);
      
      res.json({
        success: true,
        data: result,
        originalTerm: term,
        metadata: {
          aiGenerated: true,
          model: 'gpt-4.1-nano',
          verificationStatus: 'unverified',
          disclaimer: 'These improvements were generated by AI and require review before application.'
        }
      });
    } catch (error) {
      console.error('Error improving definition:', error);
      res.status(500).json({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to improve definition'
      });
    }
  });

  // Apply AI-generated improvements to a term
  app.put('/api/ai/apply-improvements/:id', mockIsAuthenticated, async (req: any, res) => {
    try {
      const termId = req.params.id;
      const { improvements } = req.body;
      
      // Only allow admin to apply improvements
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({ 
          success: false, 
          error: "Admin privileges required" 
        });
      }

      const term = await storage.getTermById(termId);
      if (!term) {
        return res.status(404).json({ 
          success: false, 
          error: 'Term not found' 
        });
      }

      // Update the term with AI improvements
      const updatedTerm = await storage.updateTerm(termId, {
        shortDefinition: improvements.shortDefinition || term.shortDefinition,
        definition: improvements.definition || term.definition,
        characteristics: improvements.characteristics || term.characteristics,
        applications: improvements.applications || (term as any).applications,
        mathFormulation: improvements.mathFormulation || term.mathFormulation
      });

      res.json({
        success: true,
        data: updatedTerm
      });
    } catch (error) {
      console.error('Error applying improvements:', error);
      res.status(500).json({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to apply improvements'
      });
    }
  });

  // ========================
  // AI Content Feedback System
  // ========================

  // Submit feedback for AI-generated content
  app.post('/api/ai/feedback', mockIsAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { termId, sectionName, feedbackType, rating, comment } = req.body;

      if (!termId || !feedbackType) {
        return res.status(400).json({
          success: false,
          error: 'Term ID and feedback type are required'
        });
      }

      // Import db and schema
      const { db } = await import('./db');
      const { aiContentFeedback } = await import('../shared/enhancedSchema');

      // Insert feedback into database
      const [feedback] = await db.insert(aiContentFeedback).values({
        termId,
        userId,
        section: sectionName || null,
        feedbackType,
        description: comment || 'User feedback',
        status: 'pending'
      }).returning();

      res.json({
        success: true,
        message: 'Feedback submitted successfully',
        data: feedback
      });
    } catch (error) {
      console.error('Error submitting feedback:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to submit feedback'
      });
    }
  });

  // Get feedback list (admin only)
  app.get('/api/ai/feedback', mockIsAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Admin privileges required'
        });
      }

      const { status = 'all', limit = 50, offset = 0 } = req.query;

      // Import db and schema
      const { db } = await import('./db');
      const { aiContentFeedback, enhancedTerms, users } = await import('../shared/enhancedSchema');
      const { eq, desc, and } = await import('drizzle-orm');

      // Build query conditions
      const conditions = [];
      if (status !== 'all') {
        conditions.push(eq(aiContentFeedback.status, status));
      }

             // Query feedback with joins
       const feedbackList = await db
         .select({
           id: aiContentFeedback.id,
           termId: aiContentFeedback.termId,
           termName: enhancedTerms.name,
           userId: aiContentFeedback.userId,
           userEmail: users.email,
           section: aiContentFeedback.section,
           feedbackType: aiContentFeedback.feedbackType,
           description: aiContentFeedback.description,
           severity: aiContentFeedback.severity,
           status: aiContentFeedback.status,
           createdAt: aiContentFeedback.createdAt,
           updatedAt: aiContentFeedback.updatedAt
         })
        .from(aiContentFeedback)
        .leftJoin(enhancedTerms, eq(aiContentFeedback.termId, enhancedTerms.id))
        .leftJoin(users, eq(aiContentFeedback.userId, users.id))
        .where(conditions.length > 0 ? and(...conditions) : undefined)
        .orderBy(desc(aiContentFeedback.createdAt))
        .limit(parseInt(limit as string))
        .offset(parseInt(offset as string));

      res.json({
        success: true,
        data: feedbackList
      });
    } catch (error) {
      console.error('Error fetching feedback:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch feedback'
      });
    }
  });

  // Update feedback status (admin only)
  app.put('/api/ai/feedback/:id', mockIsAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Admin privileges required'
        });
      }

      const { id } = req.params;
      const { status, adminNotes } = req.body;

      if (!status) {
        return res.status(400).json({
          success: false,
          error: 'Status is required'
        });
      }

      // Import db and schema
      const { db } = await import('./db');
      const { aiContentFeedback } = await import('../shared/enhancedSchema');
      const { eq } = await import('drizzle-orm');

             // Update feedback status
       const [updatedFeedback] = await db
         .update(aiContentFeedback)
         .set({
           status,
           reviewNotes: adminNotes || null,
           updatedAt: new Date()
         })
        .where(eq(aiContentFeedback.id, id))
        .returning();

      if (!updatedFeedback) {
        return res.status(404).json({
          success: false,
          error: 'Feedback not found'
        });
      }

      res.json({
        success: true,
        message: 'Feedback status updated successfully',
        data: updatedFeedback
      });
    } catch (error) {
      console.error('Error updating feedback status:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update feedback status'
      });
    }
  });

  // ========================
  // AI Content Verification
  // ========================

  // Get content verification status (admin only)
  app.get('/api/ai/verification', mockIsAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Admin privileges required'
        });
      }

      // Import db and schema
      const { db } = await import('./db');
      const { aiContentVerification, enhancedTerms } = await import('../shared/enhancedSchema');
      const { eq, count, sql } = await import('drizzle-orm');

             // Get verification statistics
       const [stats] = await db
         .select({
           total: count(),
           verified: sql<number>`count(*) filter (where ${aiContentVerification.verificationStatus} = 'verified')`,
           unverified: sql<number>`count(*) filter (where ${aiContentVerification.verificationStatus} = 'unverified')`,
           flagged: sql<number>`count(*) filter (where ${aiContentVerification.verificationStatus} = 'flagged')`
         })
         .from(aiContentVerification);

       // Get recent unverified content
       const recentUnverified = await db
         .select({
           id: aiContentVerification.id,
           termId: aiContentVerification.termId,
           termName: enhancedTerms.name,
           verificationStatus: aiContentVerification.verificationStatus,
           accuracyScore: aiContentVerification.accuracyScore,
           createdAt: aiContentVerification.createdAt
         })
         .from(aiContentVerification)
         .leftJoin(enhancedTerms, eq(aiContentVerification.termId, enhancedTerms.id))
         .where(eq(aiContentVerification.verificationStatus, 'unverified'))
        .orderBy(aiContentVerification.createdAt)
        .limit(10);

      res.json({
        success: true,
        data: {
          stats,
          recentUnverified
        }
      });
    } catch (error) {
      console.error('Error fetching verification status:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch verification status'
      });
    }
  });

  // Update content verification (admin only)
  app.put('/api/ai/verification/:id', mockIsAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Admin privileges required'
        });
      }

      const { id } = req.params;
      const { isVerified, qualityScore, verificationNotes } = req.body;

      // Import db and schema
      const { db } = await import('./db');
      const { aiContentVerification } = await import('../shared/enhancedSchema');
      const { eq } = await import('drizzle-orm');

             // Update verification status
       const [updatedVerification] = await db
         .update(aiContentVerification)
         .set({
           verificationStatus: isVerified ? 'verified' : 'unverified',
           accuracyScore: qualityScore !== undefined ? qualityScore : undefined,
           expertReviewNotes: verificationNotes || null,
           verifiedBy: userId,
           verifiedAt: isVerified ? new Date() : null,
           updatedAt: new Date()
         })
        .where(eq(aiContentVerification.id, id))
        .returning();

      if (!updatedVerification) {
        return res.status(404).json({
          success: false,
          error: 'Verification record not found'
        });
      }

      res.json({
        success: true,
        message: 'Verification updated successfully',
        data: updatedVerification
      });
    } catch (error) {
      console.error('Error updating verification:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update verification'
      });
    }
  });

  // ========================
  // AI Analytics and Monitoring
  // ========================

  // Get AI usage analytics (admin only)
  app.get('/api/ai/analytics', mockIsAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Admin privileges required'
        });
      }

      const { timeframe = '7d', operation } = req.query;
      
      // Parse timeframe
      const days = timeframe === '24h' ? 1 : timeframe === '7d' ? 7 : timeframe === '30d' ? 30 : 7;
      const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
      
      const { db } = await import('./db');
      const { aiUsageAnalytics } = await import('../shared/enhancedSchema');
      const { sql, gte, eq, and, desc } = await import('drizzle-orm');
      
      // Base query conditions
      const conditions = [gte(aiUsageAnalytics.createdAt, startDate)];
      if (operation) {
        conditions.push(eq(aiUsageAnalytics.operation, operation as string));
      }
      
      // Get summary statistics
      const [summaryResult] = await db.select({
        totalRequests: sql<number>`count(*)`,
        totalCost: sql<number>`sum(${aiUsageAnalytics.cost}::numeric)`,
        averageLatency: sql<number>`avg(${aiUsageAnalytics.latency})`,
        successRate: sql<number>`(count(*) filter (where ${aiUsageAnalytics.success} = true) * 100.0 / count(*))`,
        totalInputTokens: sql<number>`sum(${aiUsageAnalytics.inputTokens})`,
        totalOutputTokens: sql<number>`sum(${aiUsageAnalytics.outputTokens})`
      })
      .from(aiUsageAnalytics)
      .where(and(...conditions));
      
      // Get breakdown by operation
      const byOperation = await db.select({
        operation: aiUsageAnalytics.operation,
        count: sql<number>`count(*)`,
        totalCost: sql<number>`sum(${aiUsageAnalytics.cost}::numeric)`,
        avgLatency: sql<number>`avg(${aiUsageAnalytics.latency})`
      })
      .from(aiUsageAnalytics)
      .where(and(...conditions))
      .groupBy(aiUsageAnalytics.operation)
      .orderBy(desc(sql`count(*)`));
      
      // Get breakdown by model
      const byModel = await db.select({
        model: aiUsageAnalytics.model,
        count: sql<number>`count(*)`,
        totalCost: sql<number>`sum(${aiUsageAnalytics.cost}::numeric)`,
        avgLatency: sql<number>`avg(${aiUsageAnalytics.latency})`
      })
      .from(aiUsageAnalytics)
      .where(and(...conditions))
      .groupBy(aiUsageAnalytics.model)
      .orderBy(desc(sql`count(*)`));
      
      // Get timeline data (daily breakdown)
      const timeline = await db.select({
        date: sql<string>`date(${aiUsageAnalytics.createdAt})`,
        requests: sql<number>`count(*)`,
        cost: sql<number>`sum(${aiUsageAnalytics.cost}::numeric)`,
        errors: sql<number>`count(*) filter (where ${aiUsageAnalytics.success} = false)`
      })
      .from(aiUsageAnalytics)
      .where(and(...conditions))
      .groupBy(sql`date(${aiUsageAnalytics.createdAt})`)
      .orderBy(sql`date(${aiUsageAnalytics.createdAt})`);

      res.json({
        success: true,
        data: {
          summary: {
            totalRequests: Number(summaryResult?.totalRequests || 0),
            totalCost: Number(summaryResult?.totalCost || 0),
            averageLatency: Math.round(Number(summaryResult?.averageLatency || 0)),
            successRate: Math.round(Number(summaryResult?.successRate || 0) * 100) / 100,
            totalInputTokens: Number(summaryResult?.totalInputTokens || 0),
            totalOutputTokens: Number(summaryResult?.totalOutputTokens || 0)
          },
          byOperation: byOperation.reduce((acc, item) => {
            acc[item.operation] = {
              count: Number(item.count),
              totalCost: Number(item.totalCost || 0),
              avgLatency: Math.round(Number(item.avgLatency || 0))
            };
            return acc;
          }, {} as Record<string, any>),
          byModel: byModel.reduce((acc, item) => {
            acc[item.model] = {
              count: Number(item.count),
              totalCost: Number(item.totalCost || 0),
              avgLatency: Math.round(Number(item.avgLatency || 0))
            };
            return acc;
          }, {} as Record<string, any>),
          timeline: timeline.map(item => ({
            date: item.date,
            requests: Number(item.requests),
            cost: Number(item.cost || 0),
            errors: Number(item.errors)
          }))
        }
      });
    } catch (error) {
      console.error('Error fetching AI analytics:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch AI analytics'
      });
    }
  });

  // Get AI service health and status
  app.get('/api/ai/status', mockIsAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const isAdmin = await isUserAdmin(userId);
      
      if (!isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Admin privileges required'
        });
      }

      const cacheStats = aiService.getCacheStats();
      const rateLimitStatus = aiService.getRateLimitStatus();

      res.json({
        success: true,
        data: {
          status: 'healthy',
          models: {
            primary: 'gpt-4.1-nano',
            secondary: 'gpt-3.5-turbo'
          },
          cache: cacheStats,
          rateLimit: rateLimitStatus,
          lastUpdated: new Date().toISOString()
        }
      });
    } catch (error) {
      console.error('Error fetching AI status:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch AI status'
      });
    }
  });
}